{{semantics}}
In [[computer science]], an '''abstract semantic [[Graph (data structure)|graph]]''' ('''ASG''') or '''term graph''' is a form of [[abstract syntax]] in which an [[expression (computer science)|expression]] of a [[formal language|formal]] or [[programming language]] is represented by a [[Graph (discrete mathematics)|graph]] whose vertices are the expression's [[Term (mathematics)|subterm]]s. An ASG is at a higher [[abstraction (computer science)|level of abstraction]] than an [[abstract syntax tree]] (or AST), which is used to express the [[syntax|syntactic structure]] of an expression or [[program (computer science)|program]].

ASGs are more complex and concise than ASTs because they may contain shared subterms (also known as "common subexpressions").<ref name=Garner2011>{{cite journal|last=Garner|first=Richard|title=An abstract view on syntax with sharing|journal=Journal of Logic and Computation|volume=22|issue=6|pages=1427–1452|year=2011|doi=10.1093/logcom/exr021|quote=The notion of term graph encodes a refinement of inductively generated syntax in which regard is paid to the sharing and discard of subterms.|arxiv=1009.3682}}</ref> Abstract semantic graphs are often used as an [[intermediate representation]] by [[compilers]] to store the results of performing [[common subexpression elimination]] upon [[abstract syntax trees]]. ASTs are [[tree (computer science)|trees]] and are thus incapable of representing shared terms. ASGs are usually [[directed acyclic graph|directed acyclic graphs (DAG)]], although in some applications graphs containing [[cycle (graph theory)|cycles]]{{clarify|last sentence said acyclic|date=August 2017}} may be permitted. For example, a graph containing a cycle might be used to represent the [[recursive]] expressions that are commonly used in [[functional programming language]]s as non-[[loop (computing)|loop]]ing [[iteration]] constructs. The mutability of these types of graphs, is studied in the field of [[graph rewriting]].

The nomenclature ''term graph'' is associated with the field of [[graph rewriting#Term graph rewriting|term graph rewriting]],<ref name=Plump1999>{{cite book | last = Plump | first = D. | editor1-first = Hartmut | editor1-last = Ehrig| editor2-first = G. | editor2-last = Engels| editor3-first = Grzegorz | editor3-last = Rozenberg |title=Handbook of Graph Grammars and Computing by Graph Transformation: applications, languages and tools | volume = 2|year=1999|publisher=World Scientific|isbn=9789810228842|pages=9–13}}</ref> which involves the transformation and processing of expressions by the specification of rewriting rules,<ref name=Barendregt1987>{{cite book|last=Barendregt|first=H. P.|first2=M. C. J. D.|last2=van Eekelen|first3=J. R. W.|last3=Glauert|first4=J. R.|last4=Kennaway|first5=M. J.|last5=Plasmeijer|first6=M. R.|last6=Sleep|title=Term graph rewriting|journal=PARLE Parallel Architectures and Languages Europe (Lecture Notes in Computer Science)|year=1987|volume=259|pages=141–158|doi=10.1007/3-540-17945-3_8|series=Lecture Notes in Computer Science|isbn=978-3-540-17945-0}}</ref> whereas ''abstract semantic graph'' is used when discussing [[linguistics]], [[programming languages]], [[type systems]] and [[compiler|compilation]].

Abstract syntax trees are not capable of sharing subexpression nodes because it is not possible for a node in a proper tree to have more than one parent. Although this conceptual simplicity is appealing, it may come at the cost of redundant representation and, in turn, possibly inefficiently duplicating the computation of identical terms. For this reason ASGs are often used as an [[intermediate language]] at a subsequent compilation stage to abstract syntax tree construction via parsing.

An abstract semantic graph is typically constructed from an abstract syntax tree by a process of enrichment and abstraction. The enrichment can for example be the addition of [[back-pointer]]s, [[edge (graph theory)|edges]] from an [[identifier]] node (where a [[Variable (programming)|variable]] is being used) to a node representing the [[declaration (computer science)|declaration]] of that variable. The abstraction can [[logical consequence|entail]] the removal of details which are relevant only in [[parsing]], not for semantics.

== Example: Code Refactoring ==
For example, consider the case of [[code refactoring]]. To represent the implementation of a function that takes an input argument, the received parameter is conventionally given an arbitrary, distinct [[name]] in the source code so that it can be referenced. The abstract representation of this conceptual entity, a "function argument" instance, will likely be mentioned in the function signature, and also one or more times within the implementation code body. Since the function as a whole is the parent of both its header or "signature" information as well as its implementation body, an AST would not be able to use the same node to co-identify the multiple uses or appearances of the argument entity. This is solved by the DAG nature of an ASG. A key advantage of having a single, distinct node identity for any given code element is that each element's properties are, by definition, uniquely stored. This simplifies refactoring operations, because there is exactly one existential nexus for any given property instantiation. If the developer decides to change a property value such as the "name" of any code element (the "function argument" in this example), the ASG inherently exposes that value in exactly one place, and it follows that any such property changes are implicitly, trivially, and immediately propagated globally.

==See also==
*[[Abstract syntax tree]]
*[[Ontology (computer science)]]
*[[Semantic Web]]
*[[Semantic Grid]]

==References==
{{reflist}}

==External links==
* {{cite web | url = http://www.swag.uwaterloo.ca/cppx/old_cppx_site/ | title = CPPX&nbsp;— C/C++ Fact Extractor | authorlink = Tom Dean (computer scientist) | first = Tom | last = Dean }}
*{{cite paper | url = http://citeseer.ist.psu.edu/devanbu96generating.html | title = Generating Testing and Analysis Tools with Aria | authorlink1 = Premkumar T. Devanbu | first1 = Premkumar T. | last1 = Devanbu | authorlink2 = David S. Rosenblum | first2 = David S. | last2 = Rosenblum | authorlink3 = Alexander L. Wolf | first3 = Alexander L. | last3 = Wolf }}
* {{cite paper | title = Towards Portable Source Code Representations Using XML | citeseerx = 10.1.1.88.6173 | authorlink1 = Evan Mamas | first1 = Evan | last1 = Mamas | authorlink2 = Kostas Kontogiannis | first2 = Kostas | last2 = Kontogiannis }}
*{{cite conference | url = http://www.citeulike.org/user/hayashi/article/259537 | title = Dex: a semantic-graph differencing tool for studying changes in large code bases | first1 = Shruti | last1 = Raghavan | first2 = Rosanne | last2 = Rohana | first3 = David | last3 = Leon | first4 = Andy | last4 = Podgurski | first5 = Vinay | last5 = Augustine | conference = IEEE International Conference on Software Maintenance | date = 2004 | pages = 188–197 | doi = 10.1109/icsm.2004.1357803 | access-date = 2007-05-01 | archive-url = https://web.archive.org/web/20080117121308/http://www.citeulike.org/user/hayashi/article/259537 | archive-date = 2008-01-17 | url-status = dead }}

[[Category:Graph data structures]]
[[Category:Formal languages]]


{{formalmethods-stub}}{{semantics}}
In [[computer science]], an '''abstract semantic [[Graph (data structure)|graph]]''' ('''ASG''') or '''term graph''' is a form of [[abstract syntax]] in which an [[expression (computer science)|expression]] of a [[formal language|formal]] or [[programming language]] is represented by a [[Graph (discrete mathematics)|graph]] whose vertices are the expression's [[Term (mathematics)|subterm]]s. An ASG is at a higher [[abstraction (computer science)|level of abstraction]] than an [[abstract syntax tree]] (or AST), which is used to express the [[syntax|syntactic structure]] of an expression or [[program (computer science)|program]].

ASGs are more complex and concise than ASTs because they may contain shared subterms (also known as "common subexpressions").<ref name=Garner2011>{{cite journal|last=Garner|first=Richard|title=An abstract view on syntax with sharing|journal=Journal of Logic and Computation|volume=22|issue=6|pages=1427–1452|year=2011|doi=10.1093/logcom/exr021|quote=The notion of term graph encodes a refinement of inductively generated syntax in which regard is paid to the sharing and discard of subterms.|arxiv=1009.3682}}</ref> Abstract semantic graphs are often used as an [[intermediate representation]] by [[compilers]] to store the results of performing [[common subexpression elimination]] upon [[abstract syntax trees]]. ASTs are [[tree (computer science)|trees]] and are thus incapable of representing shared terms. ASGs are usually [[directed acyclic graph|directed acyclic graphs (DAG)]], although in some applications graphs containing [[cycle (graph theory)|cycles]]{{clarify|last sentence said acyclic|date=August 2017}} may be permitted. For example, a graph containing a cycle might be used to represent the [[recursive]] expressions that are commonly used in [[functional programming language]]s as non-[[loop (computing)|loop]]ing [[iteration]] constructs. The mutability of these types of graphs, is studied in the field of [[graph rewriting]].

The nomenclature ''term graph'' is associated with the field of [[graph rewriting#Term graph rewriting|term graph rewriting]],<ref name=Plump1999>{{cite book | last = Plump | first = D. | editor1-first = Hartmut | editor1-last = Ehrig| editor2-first = G. | editor2-last = Engels| editor3-first = Grzegorz | editor3-last = Rozenberg |title=Handbook of Graph Grammars and Computing by Graph Transformation: applications, languages and tools | volume = 2|year=1999|publisher=World Scientific|isbn=9789810228842|pages=9–13}}</ref> which involves the transformation and processing of expressions by the specification of rewriting rules,<ref name=Barendregt1987>{{cite book|last=Barendregt|first=H. P.|first2=M. C. J. D.|last2=van Eekelen|first3=J. R. W.|last3=Glauert|first4=J. R.|last4=Kennaway|first5=M. J.|last5=Plasmeijer|first6=M. R.|last6=Sleep|title=Term graph rewriting|journal=PARLE Parallel Architectures and Languages Europe (Lecture Notes in Computer Science)|year=1987|volume=259|pages=141–158|doi=10.1007/3-540-17945-3_8|series=Lecture Notes in Computer Science|isbn=978-3-540-17945-0}}</ref> whereas ''abstract semantic graph'' is used when discussing [[linguistics]], [[programming languages]], [[type systems]] and [[compiler|compilation]].

Abstract syntax trees are not capable of sharing subexpression nodes because it is not possible for a node in a proper tree to have more than one parent. Although this conceptual simplicity is appealing, it may come at the cost of redundant representation and, in turn, possibly inefficiently duplicating the computation of identical terms. For this reason ASGs are often used as an [[intermediate language]] at a subsequent compilation stage to abstract syntax tree construction via parsing.

An abstract semantic graph is typically constructed from an abstract syntax tree by a process of enrichment and abstraction. The enrichment can for example be the addition of [[back-pointer]]s, [[edge (graph theory)|edges]] from an [[identifier]] node (where a [[Variable (programming)|variable]] is being used) to a node representing the [[declaration (computer science)|declaration]] of that variable. The abstraction can [[logical consequence|entail]] the removal of details which are relevant only in [[parsing]], not for semantics.

== Example: Code Refactoring ==
For example, consider the case of [[code refactoring]]. To represent the implementation of a function that takes an input argument, the received parameter is conventionally given an arbitrary, distinct [[name]] in the source code so that it can be referenced. The abstract representation of this conceptual entity, a "function argument" instance, will likely be mentioned in the function signature, and also one or more times within the implementation code body. Since the function as a whole is the parent of both its header or "signature" information as well as its implementation body, an AST would not be able to use the same node to co-identify the multiple uses or appearances of the argument entity. This is solved by the DAG nature of an ASG. A key advantage of having a single, distinct node identity for any given code element is that each element's properties are, by definition, uniquely stored. This simplifies refactoring operations, because there is exactly one existential nexus for any given property instantiation. If the developer decides to change a property value such as the "name" of any code element (the "function argument" in this example), the ASG inherently exposes that value in exactly one place, and it follows that any such property changes are implicitly, trivially, and immediately propagated globally.

==See also==
*[[Abstract syntax tree]]
*[[Ontology (computer science)]]
*[[Semantic Web]]
*[[Semantic Grid]]

==References==
{{reflist}}

==External links==
* {{cite web | url = http://www.swag.uwaterloo.ca/cppx/old_cppx_site/ | title = CPPX&nbsp;— C/C++ Fact Extractor | authorlink = Tom Dean (computer scientist) | first = Tom | last = Dean }}
*{{cite paper | url = http://citeseer.ist.psu.edu/devanbu96generating.html | title = Generating Testing and Analysis Tools with Aria | authorlink1 = Premkumar T. Devanbu | first1 = Premkumar T. | last1 = Devanbu | authorlink2 = David S. Rosenblum | first2 = David S. | last2 = Rosenblum | authorlink3 = Alexander L. Wolf | first3 = Alexander L. | last3 = Wolf }}
* {{cite paper | title = Towards Portable Source Code Representations Using XML | citeseerx = 10.1.1.88.6173 | authorlink1 = Evan Mamas | first1 = Evan | last1 = Mamas | authorlink2 = Kostas Kontogiannis | first2 = Kostas | last2 = Kontogiannis }}
*{{cite conference | url = http://www.citeulike.org/user/hayashi/article/259537 | title = Dex: a semantic-graph differencing tool for studying changes in large code bases | first1 = Shruti | last1 = Raghavan | first2 = Rosanne | last2 = Rohana | first3 = David | last3 = Leon | first4 = Andy | last4 = Podgurski | first5 = Vinay | last5 = Augustine | conference = IEEE International Conference on Software Maintenance | date = 2004 | pages = 188–197 | doi = 10.1109/icsm.2004.1357803 | access-date = 2007-05-01 | archive-url = https://web.archive.org/web/20080117121308/http://www.citeulike.org/user/hayashi/article/259537 | archive-date = 2008-01-17 | url-status = dead }}

[[Category:Graph data structures]]
[[Category:Formal languages]]


{{formalmethods-stub}}